

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>SimulationUtilities.Curve &mdash; MOlecular Dynamics Over Ip - University of Bath</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="MOlecular Dynamics Over Ip - University of Bath" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        

        
          <a href="../../index.html" class="icon icon-home"> MODOI
        

        
        </a>

        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../Algorithm.html">The Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Tutorial.html">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Tutorial.html#butane-simulation">Butane Simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Tutorial.html#configuring-modoi-for-butane">Configuring MODOI for Butane</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Tutorial.html#running-the-simulation">Running the Simulation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Implementations.html">Implementations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Local_Simulation.html">Local_Simulation Script</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Components.html">Components</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../SimulationClient.html">SimulationClient Package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../SimulationClient.html#module-SimulationClient.SimulationClient">SimulationClient.SimulationClient Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../SimulationClient.html#module-SimulationClient.CustomBFGS">SimulationClient.CustomBFGS Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../SimulationClient.html#module-SimulationClient.Geometric">SimulationClient.Geometric Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../SimulationClient.html#module-SimulationClient.LinearAlgebra">SimulationClient.LinearAlgebra Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../SimulationClient.html#module-SimulationClient.MetricValues">SimulationClient.MetricValues Module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../SimulationPotential.html">SimulationPotential Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../SimulationServer.html">SimulationServer Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../SimulationUtilities.html">SimulationUtilities Package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../SimulationUtilities.html#module-SimulationUtilities.Communication_Codes">SimulationUtilities.Communication_Codes Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../SimulationUtilities.html#module-SimulationUtilities.Configuration_Processing">SimulationUtilities.Configuration_Processing Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../SimulationUtilities.html#module-SimulationUtilities.Curve">SimulationUtilities.Curve Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../SimulationUtilities.html#module-SimulationUtilities.Extract_States_PDB">SimulationUtilities.Extract_States_PDB Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../SimulationUtilities.html#module-SimulationUtilities.Visualize">SimulationUtilities.Visualize Module</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">MODOI</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">Module code</a> &raquo;</li>
      
    <li>SimulationUtilities.Curve</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <h1>Source code for SimulationUtilities.Curve</h1><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">linalg</span> <span class="k">as</span> <span class="n">la</span>


<div class="viewcode-block" id="Curve"><a class="viewcode-back" href="../../SimulationUtilities.html#SimulationUtilities.Curve.Curve">[docs]</a><span class="k">class</span> <span class="nc">Curve</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    The purpose of this object is to provide a Curve object that has similar behaviour to that described in [Sutton2013]_.</span>

<span class="sd">    Attributes:</span>
<span class="sd">      start_point (numpy.array): A NumPy array describing the first point in the curve.</span>
<span class="sd">      end_point (numpy.array): A NumPy array describing the last point in the curve.</span>
<span class="sd">      number_of_nodes (int): The total number of nodes that the curve is to consist of, including the start and end points.</span>
<span class="sd">      total_number_of_nodes (int): The total number of nodes in the curve, including local_nodes - only used to compute the correct scaling of the tangent vector.</span>
<span class="sd">      tangent (numpy.array): The tangent of the straight line segment joining the start_point to the end_point, rescaled according to [Sutton2013]_.</span>
<span class="sd">      points (numpy.array): An NumPy array containing all the points of the curve.</span>
<span class="sd">      default_initial_state (numpy.array): A NumPy array consisting of flags that indicate which nodes are movable initially.</span>
<span class="sd">      movement (float): A variable which records the total movement of the curve as calculated in [Sutton2013]_.</span>
<span class="sd">      nodes_moved (numpy.array): A binary NumPy array indicating whether a node has been moved. Used to determine when all the nodes in the curve have been moved.</span>
<span class="sd">      node_movable (numpy.array): A binary NumPy array indicating whether a node is movable.</span>
<span class="sd">      number_of_distinct_nodes_moved (int): A counter recording the total number of nodes that have moved.</span>
<span class="sd">      configuration (dict): A dictionary containing the information from the configuration file.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_point</span><span class="p">,</span> <span class="n">end_point</span><span class="p">,</span> <span class="n">number_of_nodes</span><span class="p">,</span> <span class="n">total_number_of_nodes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The constructor for the Curve class.</span>

<span class="sd">        Note:</span>
<span class="sd">          This class is intended to be used by the SimulationServer module.</span>

<span class="sd">        Args:</span>
<span class="sd">          start_point (numpy.array): A NumPy array describing the first point in the curve.</span>
<span class="sd">          end_point (numpy.array): A NumPy array describing the last point in the curve.</span>
<span class="sd">          number_of_nodes (int): The total number of nodes that the curve is to consist of, including the start and end points.</span>
<span class="sd">          total_number_of_nodes (int): The total number of nodes in the curve, including local_nodes - only used to compute the correct scaling of the tangent vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Pass the initialiser arguments directly into the class attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">start_point</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;float64&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">end_point</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;float64&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">number_of_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_number_of_nodes</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">total_number_of_nodes</span><span class="p">)</span>

        <span class="c"># Compute the tangent vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tangent</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">end_point</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_point</span><span class="p">)</span>

        <span class="c"># Compute the initial curve, the straight line joining the start point to the end point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">start_point</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;float64&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">tangent</span><span class="p">)]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">end_point</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c"># Create and definite initial node_movable configuration. In this case even numbered nodes first.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_initial_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;int&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">default_initial_state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="c"># Create all of the flags in the curve to indicate that the nodes in default_initial_state are movable.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">movement</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_moved</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;int&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_movable</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">default_initial_state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number_of_distinct_nodes_moved</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c"># Create the attribute to store the simulation configuration.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">configuration</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="Curve.set_node_movable"><a class="viewcode-back" href="../../SimulationUtilities.html#SimulationUtilities.Curve.Curve.set_node_movable">[docs]</a>    <span class="k">def</span> <span class="nf">set_node_movable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Resets all of the flags in the curve to indicate that the nodes in default_initial_state are movable.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            node_number (int): The node number of the node whose position is to be updated.</span>
<span class="sd">            new_position (numpy.array): The new position of the node.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">movement</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_moved</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;int&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_movable</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">default_initial_state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number_of_distinct_nodes_moved</span> <span class="o">=</span> <span class="mi">0</span>
</div>
<div class="viewcode-block" id="Curve.set_node_position"><a class="viewcode-back" href="../../SimulationUtilities.html#SimulationUtilities.Curve.Curve.set_node_position">[docs]</a>    <span class="k">def</span> <span class="nf">set_node_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_number</span><span class="p">,</span> <span class="n">new_position</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Update the position of the node at node_number to new_position. This processes the logic for releasing</span>
<span class="sd">        neighbouring nodes for further computation.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            node_number (int): The node number of the node whose position is to be updated.</span>
<span class="sd">            new_position (numpy.array): The new position of the node.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Arithmetic to measure the total movement of a curve</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">movement</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">))</span> <span class="o">*</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">new_position</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">node_number</span><span class="p">]),</span> <span class="nb">ord</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="c"># Update position of node with new position assumes new_position is float64 numpy array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">node_number</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_position</span>

        <span class="c"># Arithmetic for determining if an existing nodes neighbours have been moved</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_movable</span><span class="p">[</span><span class="n">node_number</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_movable</span><span class="p">[</span><span class="n">node_number</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_movable</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_movable</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">node_number</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node_movable</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node_movable</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">node_number</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="o">-</span><span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node_movable</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node_movable</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c"># Arithmetic to keep track of how many nodes have been moved distinctly</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_moved</span><span class="p">[</span><span class="n">node_number</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number_of_distinct_nodes_moved</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_moved</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Curve.next_movable_node"><a class="viewcode-back" href="../../SimulationUtilities.html#SimulationUtilities.Curve.Curve.next_movable_node">[docs]</a>    <span class="k">def</span> <span class="nf">next_movable_node</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Determine next movable node, given existing information about previously distributed nodes.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The node number of the next movable node. If no such node exists then it returns None.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># This will get quicker with NumPy 2.0.0 - https://github.com/numpy/numpy/issues/2269</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c"># Determine the node number of the next movable node in the next_movable_node array. This particular test</span>
            <span class="c"># attempts to find a node that has not been previously moved.</span>
            <span class="n">next_movable_node</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_movable</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_moved</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="c"># If there is no node available that hasn&#39;t been previously moved then...</span>
            <span class="k">if</span> <span class="n">next_movable_node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>

                <span class="c"># Simply find a node that is movable. This time we include previously moved nodes in our search</span>
                <span class="n">next_movable_node</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_movable</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="c"># If we still couldn&#39;t find a node...</span>
            <span class="k">if</span> <span class="n">next_movable_node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>

                <span class="c"># Return None</span>
                <span class="k">return</span> <span class="bp">None</span>

            <span class="c"># Otherwise...</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="c"># Mark the node as no longer movable to prevent it being re-issued.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">node_movable</span><span class="p">[</span><span class="n">next_movable_node</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c"># Return the node number</span>
                <span class="k">return</span> <span class="n">next_movable_node</span>

        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="Curve.get_points"><a class="viewcode-back" href="../../SimulationUtilities.html#SimulationUtilities.Curve.Curve.get_points">[docs]</a>    <span class="k">def</span> <span class="nf">get_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Accessor method for the points attribute.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array: An array containing all of the points of the curve.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span>
</div>
<div class="viewcode-block" id="Curve.all_nodes_moved"><a class="viewcode-back" href="../../SimulationUtilities.html#SimulationUtilities.Curve.Curve.all_nodes_moved">[docs]</a>    <span class="k">def</span> <span class="nf">all_nodes_moved</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; This method determines whether every node in the global curve has been tested for length reduction.</span>

<span class="sd">        Returns:</span>
<span class="sd">          bool: True if all of the nodes have been tested, False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_distinct_nodes_moved</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span></div></div>
</pre></div>

          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Daniel C. Sutton.
    </p>
  </div>

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>